{"ast":null,"code":"function getHeapSortAnimations(array) {\n  const animations = [];\n  buildMaxHeap(array);\n\n  for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n    swap(0, endIdx, array, animations);\n    siftDown(0, endIdx - 1, array);\n  }\n\n  return array;\n}\n\nfunction buildMaxHeap(array) {\n  const firstParentIdx = Math.floor((array.length - 2) / 2);\n\n  for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n    siftDown(currentIdx, array.length - 1, array);\n  }\n}\n\nfunction siftDown(currentIdx, endIdx, heap) {\n  let childOneIdx = currentIdx * 2 + 1;\n\n  while (childOneIdx <= endIdx) {\n    const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n    let idxToSwap;\n\n    if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n      idxToSwap = childTwoIdx;\n    } else {\n      idxToSwap = childOneIdx;\n    }\n\n    if (heap[idxToSwap] > heap[currentIdx]) {\n      swap(currentIdx, idxToSwap, heap);\n      currentIdx = idxToSwap;\n      childOneIdx = currentIdx * 2 + 1;\n    } else {\n      return;\n    }\n  }\n}\n\nfunction swap(i, j, array, animations) {\n  const temp = array[j]; // These are the values that we're comparing; we push them once\n  // to change their color.\n\n  animations.push([i, i + 1]); // These are the values that we're comparing; we push them once\n  // to change their color.\n\n  animations.push([i, i + 1]); // we overwrite the value at index j with value from array at index i\n  // we overwrite the value at index i with value from array at index j\n\n  animations.push([[j, array[i]], [i, array[j]]]);\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexport { getHeapSortAnimations };","map":{"version":3,"sources":["/Users/nikitaizmailov/js/react-sort-project/sorting-algorithms/src/sortingAlgorithms/heapSortLogic.js"],"names":["getHeapSortAnimations","array","animations","buildMaxHeap","endIdx","length","swap","siftDown","firstParentIdx","Math","floor","currentIdx","heap","childOneIdx","childTwoIdx","idxToSwap","i","j","temp","push"],"mappings":"AAAA,SAASA,qBAAT,CAA+BC,KAA/B,EAAsC;AAClC,QAAMC,UAAU,GAAG,EAAnB;AACAC,EAAAA,YAAY,CAACF,KAAD,CAAZ;;AACA,OAAK,IAAIG,MAAM,GAAGH,KAAK,CAACI,MAAN,GAAe,CAAjC,EAAoCD,MAAM,GAAG,CAA7C,EAAgDA,MAAM,EAAtD,EAA0D;AACtDE,IAAAA,IAAI,CAAC,CAAD,EAAIF,MAAJ,EAAYH,KAAZ,EAAmBC,UAAnB,CAAJ;AACAK,IAAAA,QAAQ,CAAC,CAAD,EAAIH,MAAM,GAAG,CAAb,EAAgBH,KAAhB,CAAR;AACH;;AACD,SAAOA,KAAP;AACH;;AAED,SAASE,YAAT,CAAsBF,KAAtB,EAA6B;AACzB,QAAMO,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACT,KAAK,CAACI,MAAN,GAAe,CAAhB,IAAqB,CAAhC,CAAvB;;AACA,OAAK,IAAIM,UAAU,GAAGH,cAAtB,EAAsCG,UAAU,IAAI,CAApD,EAAuDA,UAAU,EAAjE,EAAqE;AACjEJ,IAAAA,QAAQ,CAACI,UAAD,EAAaV,KAAK,CAACI,MAAN,GAAe,CAA5B,EAA+BJ,KAA/B,CAAR;AACH;AACJ;;AAED,SAASM,QAAT,CAAkBI,UAAlB,EAA8BP,MAA9B,EAAsCQ,IAAtC,EAA4C;AACxC,MAAIC,WAAW,GAAGF,UAAU,GAAG,CAAb,GAAiB,CAAnC;;AACA,SAAOE,WAAW,IAAIT,MAAtB,EAA8B;AAC1B,UAAMU,WAAW,GAAGH,UAAU,GAAG,CAAb,GAAiB,CAAjB,IAAsBP,MAAtB,GAA+BO,UAAU,GAAG,CAAb,GAAiB,CAAhD,GAAoD,CAAC,CAAzE;AACA,QAAII,SAAJ;;AACA,QAAID,WAAW,KAAK,CAAC,CAAjB,IAAsBF,IAAI,CAACE,WAAD,CAAJ,GAAoBF,IAAI,CAACC,WAAD,CAAlD,EAAiE;AAC7DE,MAAAA,SAAS,GAAGD,WAAZ;AACH,KAFD,MAEO;AACHC,MAAAA,SAAS,GAAGF,WAAZ;AACH;;AAAC,QAAID,IAAI,CAACG,SAAD,CAAJ,GAAkBH,IAAI,CAACD,UAAD,CAA1B,EAAwC;AACtCL,MAAAA,IAAI,CAACK,UAAD,EAAaI,SAAb,EAAwBH,IAAxB,CAAJ;AACAD,MAAAA,UAAU,GAAGI,SAAb;AACAF,MAAAA,WAAW,GAAGF,UAAU,GAAG,CAAb,GAAiB,CAA/B;AACH,KAJC,MAIK;AACH;AACH;AACJ;AACJ;;AAED,SAASL,IAAT,CAAcU,CAAd,EAAiBC,CAAjB,EAAoBhB,KAApB,EAA2BC,UAA3B,EAAuC;AACnC,QAAMgB,IAAI,GAAGjB,KAAK,CAACgB,CAAD,CAAlB,CADmC,CAGnC;AACA;;AACAf,EAAAA,UAAU,CAACiB,IAAX,CAAgB,CAACH,CAAD,EAAIA,CAAC,GAAC,CAAN,CAAhB,EALmC,CAOnC;AACA;;AACAd,EAAAA,UAAU,CAACiB,IAAX,CAAgB,CAACH,CAAD,EAAIA,CAAC,GAAC,CAAN,CAAhB,EATmC,CAUnC;AACA;;AACAd,EAAAA,UAAU,CAACiB,IAAX,CAAgB,CAAC,CAACF,CAAD,EAAIhB,KAAK,CAACe,CAAD,CAAT,CAAD,EAAgB,CAACA,CAAD,EAAIf,KAAK,CAACgB,CAAD,CAAT,CAAhB,CAAhB;AAEAhB,EAAAA,KAAK,CAACgB,CAAD,CAAL,GAAWhB,KAAK,CAACe,CAAD,CAAhB;AACAf,EAAAA,KAAK,CAACe,CAAD,CAAL,GAAWE,IAAX;AACH;;AAED,SAAQlB,qBAAR","sourcesContent":["function getHeapSortAnimations(array) {\n    const animations = [];\n    buildMaxHeap(array);\n    for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n        swap(0, endIdx, array, animations);\n        siftDown(0, endIdx - 1, array);\n    }\n    return array;\n}\n\nfunction buildMaxHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.length - 1, array);\n    }\n}\n\nfunction siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n        const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        let idxToSwap;\n        if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n            idxToSwap = childTwoIdx;\n        } else {\n            idxToSwap = childOneIdx;\n        } if (heap[idxToSwap] > heap[currentIdx]) {\n            swap(currentIdx, idxToSwap, heap);\n            currentIdx = idxToSwap;\n            childOneIdx = currentIdx * 2 + 1;\n        } else {\n            return;\n        }\n    }\n}\n\nfunction swap(i, j, array, animations) {\n    const temp = array[j];\n\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i+1]);\n\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i+1]);\n    // we overwrite the value at index j with value from array at index i\n    // we overwrite the value at index i with value from array at index j\n    animations.push([[j, array[i]], [i, array[j]]]);\n\n    array[j] = array[i];\n    array[i] = temp;\n}\n\nexport {getHeapSortAnimations};"]},"metadata":{},"sourceType":"module"}